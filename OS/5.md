# 프로세스 동기화, 임계구역 문제

## contents

-   [Thread(쓰레드)](#Thread)
-   [프로세스 동기화](#프로세스-동기화)
-   [임계구역 문제](#임계구역-문제)

# Thread

쓰레드란, 프로그램 내부의 흐름을 말한다. 보통 1개의 프로그램에는 1개의 흐름이 존재하지만, 여러개의 흐름이 존재하는 경우 multiThread(다중 쓰레드)라고 한다.

이렇게 멀티쓰레드를 가질 수 있는 이유는, 쓰레드가 매우 빠른 간격으로 switcing 되고있기 떄문이다. 그래서 실제로 cpu는 하나이기 때문에 한개의 쓰레드만 실행될 수 있지만, 여러개의 쓰레드가 동시에 실행되는 것 처럼 느낄 수 있는 것이다.

`concurrent`[실제로는하나지만빠른스위칭때문에동시처럼보임] vs `simultaneous`[실제로2개가실행.cpu가 한개일경우 이런일은 있을 수 없음 ㅎ]의 용어도 알아두자.

예시를 보면, 사실 대부분의 프로그램은 다중 쓰레드 프로그램이다.

-   web browser - 화면 출력 Thread + 데이터 읽어오는 Thread
-   word processor - 화면 출력 Thread + 키보드 입력받는 Thread + 철자/문법/오류 확인 Thread

### Thread vs Process

사실 P1의 쓰레드가 실행되고, P1의 다른 쓰레드가 실행되고, P2의 다른쓰레드 실행.. 이렇게 사실 현대의 운영체제는 쓰레드 스위칭을 위주로 work 처리가 일어난다. 다시말해, **context switching단위가 process 가 아니라 thread 라는 것**

✨ mem의 하나의 프로세스 내에서 많은 쓰레드는 code, data를 공유한다. 하지만 stack은 공유하지 않는다.(단일 쓰레드가 끝나면 또다른프로세스의 또다른 쓰레드를 처리하러 ㅌㅌ해야하기때문. 서로 처리하는 메서드가 다를것이기 때문!!)

쓰레드의 구조를 정리해보자.

-   프로세스의 메모리 공간 공유 : code, data
-   프로세스의 자원 공유 : file, i/o
-   비공유 : 개별적인 PC(program counter), SP, registers, stack

### Example

자바 쓰레드를 보자.
자바에서 새로운 쓰레드를 만들려면, 객체로 생성해야한다. `java.lang.Thread` 임.

주요 메서드

-   public void run() # 새로운 맥이 흐르는 곳. 내부에 치환하여 여러가지 코드를 추가한다.
-   void start() # 쓰레드 시작 요청
-   void join() # 쓰레드가 마치기를 기다림
-   static void sleep() # 쓰레드 잠자기

자바쓰레드의 example 시나리오를 보자.

쓰레드가 시작되면 `run()`메소드가 실행된다 => `run()` 메소드를 치환(override)한다.

    ```
    class Test {
        private static void main(String[] args){
            MyThread th = new MyThread();
            th.start();
            while(true){
                System.out.print("A");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {}
            }
        }
    }

    class MyThread extends Thread {
        // 상속의 이유 : 이 메서드를 치환해주기 위해 하위클래스를 만들어 상속하게끔 함.
        // override. 치환.
        public void run() {
            while(true){
                System.out.print("B");
                try {
                    sleep(100);
                } catch (InterruptedException e) {}
            }
        }
    }
    ```

위처럼 코드를 작성해보면, A와 B가 섞여서 출력되는 것을 확인할 수 있다.

<figure>  
        <img src="./img/5-1.jpeg" width=50%>
        <figcaption>example의 Thread</figcaption>
</figure>

그렇다면, 왜 쓰레드를 이야기하고있는가?

사실 프로세스 관리 부서에서해야하는 중요한 일에는 크게 두가지가 있다.

1. CPU 스케쥴링
2. Thread, Process의 동기화

# 프로세스 동기화

Process Synchronization. 하지만, 위에 쓰레드 설명에 의하면 사실은 P1, P2,,, 가 번갈아가며 처리가되는것이 아니라 각 프로세서내의 Thread1, Th2.. 가 번갈아가며 처리되는것이라고 했다. 그러므로 `Thread synchronization`이라고 할 수 있는 것!

이 프로세스 동기화를 두 부류로 나눌 수 있다.

## Independent vs Cooperating

-   Independent Processor : P1, P2 가 아무런 관계가 없는 독립적인 프로세서일 경우
-   Cooperating Processor : P1, P2가 서로 영향을 주고 받는 경우.(영향을 주던지 영향을 받던지)
    -   프로세스간 통신 ex. 전자우편, 파일 전송
    -   프로세스간 자원 공유 ex. 메모리상의 자료들, db, realtime Service ...

일반적으로 cooperating processor의 경우가 훨씬 많음

결국 프로세스 동기화는 어떤 업무를 하는가여!! 왜 동기화가중요하냐?? 동시에 접근하려하는 경우, 동기화가 잘 되지 않는다면 수강신청이나 은행계좌.. 등 다양한 서비스에서 문제가 생길 수 있다.

그래서 서로간 영향을 주는 `Cooperating Processor`의 경우에 동기화 문제가 발생할 수 있으므로 data[**Concurrent access to shared data**]의 consistency(일관성-각프로세스는 서로영향안줌)를 보장할수있어야한다는 조건이 추가된다.

☹️ 이것이 보장되지 않으면 `Data Inconsistency(데이터 모순)`의 상황이 발생할 수 있음

그래서 예제를 통해서 확인해본 결과, ex. 입출금 동작에 시간지연을 추가했더니 => 잘못된 결과값! 이 나타났다...

-   왜❓ 공통변수(common variable)에대한 동시 업데이트 (`concurrent update`)가 일어났기 때문이다.
-   해결❗️ **common variable에 접근할 경우 한번에 한 쓰레드만 업데이트하도록**, `임계구역 문제`를 신경써서 처리해주어야한다.

즉, 동기화의경우 atomic하게. 동시에 접근하지 못하게 해야한다.(도중에 context switching이 일어나면 안된다.)

# 임계구역 문제

## Critical Section, Critical Section Problem

-   Critical Section(어떤 특정 코드가 작동하는 영역) Problem[임계구역 문제] : `common variable`을 update하는 구역에 생기는 문제들을 말한다. common variables 부분을 update하거나 write 하는 경우..
-   다시한번 정리해보면 Critical Section : 하나의 시스템에는 여러개의 쓰레드(멀티 쓰레드)로 구성되어있는데, common으로 사용하는 부분이 있다. 그 부분을 업데이트 하는 부분의 코드를 말한다.
-   예를들어, Parent 클래스에서 계좌의 balance에 접근하여 연산하고, Child클래스에서도 계좌의 balance에 접근하여 연산하는 코드가 있을 텐데, 그 코드부분을 Critical Section이라고 한다.
-   common variables의 예 : 같이 사용하는 영역의 variable, file, code, db ...

### 임계구역 문제의 Solution

-   Mutual Exclusion(상호배타) : 오직 한 쓰레드만 진입가능하게 한다.
    -   ex. Parent <-> Child 둘중 하나만 들어갈수있게 한다.
-   Progress(진행) : 정해진 시간(유한 시간)내에 입장을 결정한다.
    -   ex. 유한시간 내에 Parent, Child 둘 중 누가 먼저 들어갈것인지를 결정한다.
-   Bounded Waiting(유한 대기) : 어떤 스레드라도 기다리고있다면 유한 시간 내에는 꼭 Critical Section안에 들어갈 수 있어야한다.

이 세가지가 전부 만족되어져야 Critical Section Problem을 Solution 할 수 있다.

## 프로세스/쓰레드의 동기화

-   임계구역 문제 해결(Mutual Exclusion, Progress, Bounded Waiting) : 틀린답이 나오면 안됨
-   프로세스 실행 순서 제어 : 원하는대로 실행순서를 제어할 수 있어야한다
-   Busy wait 등 비효율성은 제거 ~~나중에 더 추가로 나올예정~~

### ✏️현재까지의 정리

OS는

1. Process Management
    - CPU Scheduling : ex. FCFS, RR, SJF ...
    - Synchronization : for 임계구역문제 해결, 프로세스 실행순서 제어, 비효율성 체크
2. Main Mem Management
3. File System
4. I/O

를 해야한다고 배웠다.
그런데, 동기화이야기가 갑자기 왜 나오냐 ?!?

컴퓨터의 자원은 한정되어있고, cpu에서만 작업을 처리할 수 있다. 메모리에서는 기다리고있었다가, 작업 처리를 대기할뿐. 하지만 컴퓨터 작업은 최대한 빨리 처리되는게 좋기 때문에, Synchronization 을 통해 (ex. TSS도 그렇고) 프로세스를 처리시키고 아웃시키고 다시들어오게하고.. 너무 작업이 길어진다면 내쫓기도 하고.. 하는데 그때 그 자원/데이터의 효율적인 처리를 하기위해, 상호 독립적으로 프로세스를 처리하기 위해서 필요한 개념이 Synchronization이다.

그래서 아주 빠른 시간내에 빠른 switching & process 가 일어나는 Sync로 인하여, 서로의 상태를 주시하며 코드가 서로 간섭하지 않게 하려면 임계구역문제를 해결해야하고, 프로세스의 실행 순서를 제어할수있게 해야하고 비효율성을 체크해야한다는 것이다.

그렇다면 그 동기화를 어떻게 꼬이지 않게 할수있는건지, Synchronization Tools에 대해 한번 알아보자.

## 동기화 도구(Synchronication Tools)

-   Semaphores
-   Monitors ex. JAVA에서 많이 씀

가 있다. 그중에서, 동기화를 의미있게. 가능케하는. 몇가지 Tools를 알아보자.

### Semaphores (세마포)

-   동기화 문제 해결을 위한 sw 도구
-   쉽게말하면 A class와 B class~~둘이부모자식관계가아닐수도있음~~가 Critical Section을 가질 경우(공통된 common variables를 가지고있을경우) A class 가 들어가면 B 클래스를 들어가지 못하게 하는 개념이다
-   구조 : 정수형 변수 + P, V동작(2가지 mode)
    -   `P` : 정수값을 검사한다. test -> acquire()
        ```
        void acquire() {
            value--;
            if(value < 0) {
                add this process/thread to list; // 어떤 프로세스나 쓰레드가 acquire()을 실행시키면 list(queue)에 집어넣고
                block; // 누가 꺼내기 전까지는 멈춰있는다
            }
        }
        ```
    -   `V` : 정수값을 증가시킨다. increment -> release()
        ```
        void release() {
            value++;
            if(value <= 0){
                remove a process P from list; // 어떤 프로세스나 쓰레드가 release()를 실행시키면 list(queue)에서 뺄것이다
                wakeup P; // Queue(list)에서 해방시킨다
            }
        }
        ```
    -   마치 스택에서 push, pop 을 하듯 release, acquire가 있다고 생각하면 편할듯 하다.

시나리오를 한번 그려보자.

Parent, Child 클래스 내부에 balance에 접근하는 연산코드가 있다.

1. Parent가 접근하는 동안에는 Child는 접근을 금지시키려한다.
2. 그러면 `p.acquire()` -> balance연산 -> `p.release()` 순서로 코드 사용이 되는데
3. 그떄 release에서 value++;하게되고
4. child가 해당 영역(Critical Section)의 코드를 사용하려고 하면, (`c.release()` -> balance연산 -> `c.acquire()`가 진행되려고 할 때)
5. child는 release() 연산에서 if에서 걸려서, process/thread 가 queue(list)에 대기하게된다.

> > Sync되게 사용할 경우 (쓰레드 겁나 빨ㄹ리 스위칭하는경우) 지연시간이 있으니까, context switching이 이루어지면서 Critical section 문제를 해결할 수 없었는데 Semaphore를 사용함으로써 Critical Section Problem을 해결!!

실제로 Semaphore docs를 읽어보면 exception 처리 (sw interrupt)를 하는 코드가 실제로 써있다. acquire시 try catch로 막아버림. 그래서 지연시간이 길던 짧던, 정확한 결과를 가져올 수 있는것이다. Critical Section 에서 서로 간섭할 수 없도록 만든게 세마포.
