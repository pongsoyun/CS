# 메모리

## contents

-   [주기억장치 관리 개요](#주기억장치-관리-개요)
-   [메모리 절약](#메모리-절약)
-   [연속메모리할당](#연속메모리할당)

# 주기억장치 관리 개요

메모리용량도 많이 늘어났지만 처리하는 데이터(프로그램)가 더 커졌고, 처리도 빨라져야한다. 메모리는 언제나 부족하다. 그래서, 메모리가 작은데 어떻게 하면 효과적으로 메모리를 사용할 수 있는가 !!

## 메모리 구조

<img src ="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcQ0pxWdcimbVCeFsrATusq-gtFOzNrmX_BVfC2SlZqpws3I2Nfz&usqp=CAU" width=50%>

메모리 = address + data로 구성되어있고, 프로그램의 실행에 관여하는 파일들은 다양하다.

-   source file : 어셈블리언어, high-level 언어 -> 이후 `compile`
-   object file : 컴파일, 어셈블 결과 010101 -> 이후 다양한 obj 파일(컴파일한 소스파일, library) `link`
-   executable file : 링크 결과로, 실행파일 (.exe) -> main.exe가 `HDD`에 있음
-   위 main.exe를 `main memory`에 `load` 하여 `실행`시킴
-   RAM에 프로그램이 load 되면, code, data, stack segment가 관여한다.

프로그램을 메모리에 올리는 과정을 좀 더 상세하게 생각해보자.

실행파일을 메모리에 올린다는 것은, **어디로** **어떻게** **어떠한 status bit들과함께** **꼬이지않게** 올릴지가 결정되어야한다는 뜻을 말한다. 그저 올리면 되는게아님 !!

-   메모리 몇번지에 올릴것?
-   다중 프로그래밍 환경에서는 꼬이지 않게 어떻게 처리할것?

예를들어 위와같은 치명적인 문제를 해결하기 위해서, 메모리 관련하여 몇가지 처리를 한다.

-   MMU의 `Relocation register`  
     : 해당 프로세스는 본인의 지정된 메모리 번지만 읽을 수 있다는 MMU의 다른 역할인데, Relocation register에 들어간 값 0x500이 항상 주소계산에 더해지는 값이 된다. 이 relocation register를 사용하면 메인메모리 어디에 있던지 상관없이(ex. 0x500~ 0xxxx ), cpu관점에서는 0번지~~ 0xxxx-0x500 번지에서 사용하는 것 처럼 인식 -> MMU가 항상 0x500을 더해줘 OS가 그 레지스터를 보고 주소계산을 해서 메모리에 접근!! => addresss bit 가 줄어듬!! ~~왜 이렇게 하나 싶었는데 주소표현에 사용하는 비트를 줄일수도있고해서 좋은듯!!!~~)

> CPU가 보는 주소(logical address) + MMU = MEM이 보는 주소(physical address)

컴퓨터구조에서는 논리주소, 물리주소를 구분하지 않았는데 MMU를 통해 이제 실제 주소 체계를 알게되었스요 ㅎㅎ

그래서 우리는 메인메모리 어디에도 프로그램을 올릴 수 있다!

## 메모리 낭비 방지

운영체제는 자원을 빠르게 사용, 효율을 높게하는데에 목적이 있다.

-   Dynamic Loading(동적 적재)
-   Dynamic Linking(동적 링킹)
-   Swapping

크게 3가지가 있다.

### Dynamic Loading

프로그램 실행에 반드시 필요한 루틴/데이터만 적재한다. 보통 코드는 핵 많지만, 실제로 사용되는 데이터는 전부가 아니다.

-   모든 routine이 다 사용되는 것은 아님(ex. Error처리 : 오류가 일어나지 않으면 괜히 올림 ㅎㅎ... ) -> 오류가 일어나면 그때 load
-   모든 data가 다 사용되는 것은 아님(ex. Array)
-   JAVA : 모든 클래스가 다 사용되는 것은 아님

이러한 경우가 많기 때문에, 실행 시 필요하게되면! 그 때 해당부분을 메모리에 load 한다는 개념이다.

현대의 OS들은 대부분 Dynamic Loading 함!! windows, MacOS, Linux ...

Static Loading <-> Dynamic Loading

### Dynamic Linking

여러 프로그램에 공통으로 사용되는 라이브러리루틴을(Library Routine)메모리에 중복으로 올리는 것은 낭비아닌가! 하는데서 나온 개념.

-   .exe 실행파일을 만들 때 link 하는게 아니라 라이브러리 루틴 연결을 실행시까지 미루고
-   MEM에 오직 하나의 lib 루틴만 load 되고,
-   다른 애플리케이션 실행 시 이 lib 루틴과 link 된다

ex. P1도 printf, P2도 printf를 사용한다고 하면 똑같은 코드인 printf를 두번 load 할 필요 없다는거임!! 하나만 MEM에 올려놓고, 필요할 때 그 올려진 기계어 코드를 memory에서 link해줌

ex. ftp, email 프로그램에서 똑같이 network lib를 사용하는데 둘다 올라가면 메모리 낭비니까 ㅎㅎ 하나만 MEM에 올리고 필요할 때 그 올려진 network 기계어 코드를 memory에서 link 해줌

Dynamic Linking(실행 이후 메모리에서 link) <-> Static Linking(실행파일 만들 때 link)

위와같은 Dynamic Linking 의 운영체제별 동적 링킹 파일을 보면,

-   Shared Library(동적 라이브러리) - Linux
-   DLL(Dynamic Linking Library, 동적 연결 라이브러리) - Windows

들의 이름으로 존재한다.

### Swapping

메모리의 활용도를 높이기 위해 메모리에 적재는 되어있으나 현재 사용되지 않고 있는 프로세스이미지는 잠시 내쫓는다는개념이다. ~~이미지 : 현재 프로세스가 실행되고있는 일부분~~

<figure>  
        <img src="./img/8-1.jpeg" width=50%>
        <figcaption>Swap-in, Swap-out</figcaption>
</figure>

-   OS : 엥? 이 P1 실행 안하고있네 ?
-   지금은!! 메모리에서 일단 내쫒음 ㅌㅌ
-   **Swap-out** : 실행파일의 일부(프로세스 이미지)는 메모리에서 HDD의 Backing Store(=Swap Device)로 이동( != HDD의 FileSystem 부분~~과 다른 영역의 HDD~~)
-   **Swap-in** : 이후 call 되면 다시 호출하여 사용

❓ Backing Store의 크기는 어느정도가 되어야할까 ??
❗️ 메인메모리에 적재되었다가 필요없어지는 프로세스[프로그램]을 하드의 backing store 로 이동하는거니까, MEM - OS의 크기.. 버퍼 잡아 MEM의 크기정도만 되면 될듯 !! ~~OS에서 가상메모리 지정하듯이 지정할 수 있음~~

-   Relocation register의 사용으로 인해, 하드에 적재되는 위치는 무관하다
-   프로세스 크기가 크면 backing store 입출력에 따른 부담이 크다
